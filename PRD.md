# Product Requirements Document (PRD): MenuGen

## 1.0 Product Vision and Core Principles

This document outlines the requirements for "MenuGen," a demonstration application inspired by Andrej Karpathy's MenuGen project. The application's purpose is to transform traditional, text-based restaurant menus into visually rich experiences using generative artificial intelligence. This PRD serves as the definitive blueprint for the development team.

### 1.1 The Problem and Solution

The problem is the ambiguity of text-only menus, leaving diners guessing about unfamiliar dishes. MenuGen provides an instant visual transformation: users upload a menu photo, and the AI generates representative images for each dish. The goal is to give a basic visual idea, not an exact photograph, eliminating uncertainty and enhancing the dining experience.

### 1.2 Guiding Principles for the Demo

*   Simplicity Over Complexity: The primary focus is on the flawless execution of the core user journey: Upload the photo -> direct to a new URL -> show the status -> show the extracted data -> show the images as they load in. No other features (like sharing the link) are in scope for this demo. The application should be aesthetically pleasing but minimal in functionality.
*   Embrace the "Vibe Coding" Ethos: Prioritize rapid prototyping to deliver the core AI-powered menu visualization with minimal boilerplate.
*   Strict Adherence to the Specified Tech Stack: A React frontend initialized with Vite and TypeScript, styled with Tailwind CSS, a Go backend using Gin and GORM, and a PostgreSQL database.
*   Backend-Managed AI Key: The OpenAI API key will be securely stored on the backend server and will not be exposed client-side.
*   Database-First Blob Storage: All original uploaded images and all generated images will be stored directly as binary large objects (BLOBs) within the PostgreSQL database.

### 1.3 The "Software 2.0" Context

This project operates within the "Software 2.0" paradigm, where core logic is steered by natural language prompts to a probabilistic model. The AI's non-deterministic nature means results may vary; the system design must accommodate this, focusing on displaying what is generated rather than guaranteeing perfection.

## 2.0 Core User Scenario

This scenario illustrates the ideal user journey for MenuGen.

*   Pre-condition: A user, Sarah, has a physical menu she wants to visualize.
*   Step 1: Menu Ingestion: Sarah navigates to the application's URL. She sees a simple upload interface. She selects to either take a new photo of the menu using her device's camera or chooses an existing image from her photo library.
*   Step 2: Processing and Progressive Display: Immediately after upload, the UI transitions. The application's URL updates to a unique identifier for her menu (e.g., `/menus/{uuid}`). A loading indicator appears. Shortly, the extracted text items from the menu appear on the screen, each accompanied by a spinning placeholder where an image will appear. As images are generated by the AI, they progressively load next to their corresponding text items, replacing the spinners.
*   Post-condition: Sarah has a clear visual understanding of the menu, with text items and their generated images displayed.

## 3.0 Functional Requirements and Features

### 3.1 Epic: Menu Ingestion and Processing

*   User Story 3.1.1: As a user, I can upload a menu image file (PNG or JPG).
*   User Story 3.1.2: As a mobile user, I can choose to take a photo directly or select one from my library.
*   User Story 3.1.3: As a user, upon image upload, the URL updates to a unique identifier (e.g., `/menus/{uuid}`) for the processing menu.
*   User Story 3.1.4: As a user, I see an initial loading indicator while the image is being processed on the backend.
*   User Story 3.1.5: As a user, I see the extracted menu item text and prices displayed on the screen as soon as they are available, with placeholder spinners for images.

### 3.2 Epic: Visual Menu Display

*   User Story 3.2.1: As a user, generated images progressively appear next to their corresponding text items as they are created by the AI, replacing the spinners.
*   User Story 3.2.2: As a user, the menu display is responsive and viewable on both mobile and desktop.
*   User Story 3.2.3: As a user, the original pricing information is displayed alongside the menu item text and generated image.

## 4.0 System Architecture and Technical Specifications

### 4.1 High-Level System Diagram

*   Client (React): A single-page application in the browser handling UI and polling the backend.
*   Application Server (Go): A backend service orchestrating AI processing, database interactions, and secure API key management.
*   Data Store (PostgreSQL): Stores all menu data, including original and generated image BLOBs, and job status.

### 4.2 Frontend (React)

*   Framework: React, initialized with Vite and TypeScript.
    *   Use `npm create vite@latest frontend -- --template react-ts`.
*   Styling: Tailwind CSS v3.
    *   Install: `npm install -D tailwindcss@3`.
    *   Initialize: `npx tailwindcss init`.
    *   Ensure `@tailwind base; @tailwind components; @tailwind utilities;` are imported in the main CSS file (e.g., `index.css`).
*   API Client: A simple client (e.g., using `fetch`) for backend communication. It should have a configurable base URL (e.g., `import.meta.env.VITE_API_BASE_URL`).
*   Polling: The frontend will continuously poll the `GET /api/menus/{id}` endpoint to update the UI with status, extracted text, and progressively generated images.
*   Code Location: All frontend code will reside in the `/frontend` directory.
*   Development Practices:
    *   `npm install` must be run before linting.
    *   `npm run lint` must be run frequently to ensure code quality.

### 4.3 Backend (Go)

*   Frameworks: Gin for routing, GORM for ORM.
*   Structure: Code will be organized into a minimal set of files: `models.go`, `handlers.go`, and `main.go`. All Go code will reside in the `/backend` directory.
*   Environment Variables:
    *   Read `.env` file for local development using a library (e.g., `github.com/joho/godotenv`).
    *   Prioritize system environment variables over `.env` values for production deployment (standard `os.Getenv` behavior).
    *   Required variables: `OPENAI_API_KEY`, `DB_HOST`, `DB_PORT`, `DB_USER`, `DB_PASSWORD`, `DB_NAME`, `SSL_ENABLED` (boolean, defaults to true if not set, allows disabling for dev).
*   Database Connection: Connect to PostgreSQL using individual credentials (host, port, user, password, dbname) from environment variables, not a single DB URI.
*   Auto-migrate: GORM's `AutoMigrate` feature will be used for schema management.
*   Asynchronous Processing: Menu processing will occur in a background goroutine to keep API responsive.
*   OpenAI API Integration:
    *   Use `gpt-4o` for OCR and text extraction.
    *   Use `DALL-E 3` for image generation.
    *   Critical: For OCR, use OpenAI's Structured Response API with a `json_schema` for consistent output parsing.
        ```json
        {
          "type": "object",
          "properties": {
            "items": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "item_text": {
                    "type": "string",
                    "description": "The name of the menu item."
                  },
                  "item_price": {
                    "type": "string",
                    "description": "The price of the menu item, including currency symbol if present. Can be empty if no price is found."
                  }
                },
                "required": ["item_text"],
                "additionalProperties": false
              }
            }
          },
          "required": ["items"],
          "additionalProperties": false
        }
        ```
*   CORS: All origins will be allowed for Cross-Origin Resource Sharing. This will be implemented as a Gin middleware.
*   Development Practices:
    *   Initialize Go module: `go mod init <your-module-path>`.
    *   `go fmt ./...` must be run frequently.
    *   `go vet ./...` must be run frequently.
*   SSL: SSL for the backend server should be required by default. It can be disabled in development via an environment variable (`SSL_ENABLED=false`).

### 4.4 Database (PostgreSQL)

*   Version: PostgreSQL 15.
*   Deployment: Only the database will be containerized using Docker Compose. Frontend and backend will run natively.
    *   A `docker-compose.yml` file will be provided solely for the PostgreSQL service.
*   Schema:
    *   Table: `menus`
        *   `id` UUID PRIMARY KEY
        *   `status` VARCHAR(20) (e.g., PENDING, PROCESSING, COMPLETED, FAILED)
        *   `original_image_data` BYTEA (stores the image BLOB)
        *   `created_at` TIMESTAMPTZ
        *   `updated_at` TIMESTAMPTZ
    *   Table: `menu_items`
        *   `id` UUID PRIMARY KEY
        *   `menu_id` UUID FOREIGN KEY (references `menus.id`)
        *   `item_text` TEXT
        *   `item_price` VARCHAR(20)
        *   `generated_image_data` BYTEA (stores the image BLOB)
        *   `generation_prompt` TEXT
        *   `created_at` TIMESTAMPTZ

### 4.5 API Endpoint Specifications

| HTTP Method | Endpoint Path | Description | Request Body | Success Response (2xx) |
| :---- | :---- | :---- | :---- | :---- |
| POST | /api/menus | Uploads a new menu image to create a processing job. | multipart/form-data with image file | 202 Accepted - JSON: {"menu_id": "uuid"} |
| GET | /api/menus/{id} | Fetches the status and results of a processed menu. Polled by the client. | (empty) | 200 OK - JSON object with menu status, item list, and image data (base64 encoded for transfer, or direct image URL if served by backend). |

## 5.0 Non-Functional Requirements

### 5.1 Security

*   API Key Handling: The OpenAI API key is strictly backend-managed via environment variables. It is never exposed to the client.
*   Transport Security: All communication between client and backend must be over HTTPS (TLS). This can be disabled for development via `SSL_ENABLED=false` env var.

### 5.2 Performance

*   UI Responsiveness: Initial upload should return `menu_id` in under 2 seconds. UI remains interactive.
*   Processing Time: Extracted text should appear within 10 seconds. All images for a 20-item menu aim to be generated and displayed within 90 seconds. UI shows progressive updates.

### 5.3 Usability

*   Intuitive UI: Clean, minimal, self-explanatory interface focusing on the core flow.
*   Graceful Error Handling: Clear, non-technical error messages for API issues (e.g., invalid image, OpenAI errors).

## 6.0 Development Checklist

*   Frontend initialized with Vite and React TypeScript.
*   Tailwind CSS v3 correctly installed and imported in CSS.
*   Frontend API client configured with a base URL.
*   Frontend polls backend for menu status and progressive updates.
*   Backend uses Go, Gin, and GORM.
*   Backend project (`/backend`) contains `models.go`, `handlers.go`, `main.go`.
*   Backend reads environment variables from `.env` and then system environment.
*   Backend connects to PostgreSQL using individual credentials (not a URI).
*   GORM `AutoMigrate` is configured.
*   OpenAI API key is read from `OPENAI_API_KEY` environment variable on the backend.
*   OpenAI `gpt-4o` and `DALL-E 3` models are used.
*   OpenAI `response_format` with `json_schema` is used for OCR, with `item_text` as the only required property in the inner object.
*   Original and generated images are stored as `BYTEA` in the PostgreSQL database.
*   CORS from all origins (`*`) are allowed on the backend.
*   SSL is enabled by default for backend, with an environment variable (`SSL_ENABLED=false`) to disable for dev.
*   Only PostgreSQL uses Docker Compose (`postgres:15` image); frontend and backend run natively.
*   `npm install` is run before `npm run lint` for frontend.
*   `npm run lint` is run frequently for frontend.
*   `go fmt ./...` is run frequently for backend.
*   `go vet ./...` is run frequently for backend.
*   README.md will be created upon completion, replacing this PRD.